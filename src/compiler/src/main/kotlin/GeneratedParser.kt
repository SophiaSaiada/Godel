import com.godel.compiler.*

data class ParseTreeNodeResult(
    val node: ParseTreeNode,
    val nextToken: Token?
)

const val ANSI_LEAF = "\u001B[42m\u001B[30m"
const val ANSI_RESET = "\u001B[0m"


private fun ParseTreeNode.asTreeString() =
    this.asTreeString("", true).joinToString("\n")

private fun ParseTreeNode.asTreeString(prefix: String, isTail: Boolean): List<String> =
    when (this) {
        is ParseTreeNode.Inner -> {
            val header = (prefix + (if (isTail) "└── " else "├── ") + name)
            listOf(header) +
                    children.dropLast(1).flatMap {
                        it.asTreeString(prefix + if (isTail) "    " else "│   ", false)
                    } +
                    (children.lastOrNull()?.asTreeString(
                        prefix + if (isTail) "    " else "│   ",
                        true
                    ) ?: emptyList())

        }
        is ParseTreeNode.Leaf ->
            listOf(prefix + (if (isTail) "└── " else "├── ") + ANSI_LEAF + token.content + ANSI_RESET)
        is ParseTreeNode.EpsilonLeaf ->
            listOf(prefix + (if (isTail) "└── " else "├── ") + "$name -> ε")
    }


fun parseToken(firstToken: Token?, restOfTokens: Iterator<Token>, tokenType: TokenType): ParseTreeNodeResult? =
    if (firstToken?.type == tokenType)
        ParseTreeNodeResult(ParseTreeNode.Leaf(firstToken), restOfTokens.nextOrNull())
    else throw java.lang.RuntimeException("parseToken: $firstToken, $tokenType")

fun parseToken(firstToken: Token?, restOfTokens: Iterator<Token>, keyword: Keyword): ParseTreeNodeResult? =
    if (firstToken?.equals(keyword) == true)
        ParseTreeNodeResult(ParseTreeNode.Leaf(firstToken), restOfTokens.nextOrNull())
    else throw java.lang.RuntimeException("parseToken: $firstToken, $keyword")

fun main() {
    val s1 =
        Lexer.lex(
            "if (true) { val x:   Int = 3.2 } else { val y: String = \"hello 12 world!\"; 3.2 } "
                .asSequence()
        ).iterator()
    print(parseStatements(s1.nextOrNull(), s1)?.node?.asTreeString())
}


// This part is auto-generated by the ParserGenerator
fun parseStatements(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "Statements"
    var nextToken = firstToken
    return if (firstToken?.type in listOf(
            TokenType.Whitespace,
            TokenType.OpenParenthesis,
            TokenType.DecimalLiteral,
            TokenType.Apostrophes
        ) || firstToken?.type == TokenType.Keyword && firstToken.content in listOf(
            Keyword.False.asString,
            Keyword.True.asString,
            Keyword.If.asString,
            Keyword.Val.asString
        )
    ) {
        val children = mutableListOf<ParseTreeNode>()
        parsePaddedStatement(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        parseStatementsRest(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseStatementsRest(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "StatementsRest"
    var nextToken = firstToken
    return if (firstToken?.type in listOf(TokenType.SEMI)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, TokenType.SEMI)?.let { children.add(it.node); nextToken = it.nextToken }
        parseStatements(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else ParseTreeNodeResult(ParseTreeNode.EpsilonLeaf(nodeName), nextToken)
}

fun parsePaddedStatement(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "PaddedStatement"
    var nextToken = firstToken
    return if (firstToken?.type in listOf(TokenType.Whitespace)) {
        val children = mutableListOf<ParseTreeNode>()
        parseSpacePlus(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        parseStatement(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        parseSpaceStar(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(
            TokenType.OpenParenthesis,
            TokenType.DecimalLiteral,
            TokenType.Apostrophes
        ) || firstToken?.type == TokenType.Keyword && firstToken.content in listOf(
            Keyword.False.asString,
            Keyword.True.asString,
            Keyword.If.asString,
            Keyword.Val.asString
        )
    ) {
        val children = mutableListOf<ParseTreeNode>()
        parseStatement(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        parseSpaceStar(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseStatement(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "Statement"
    var nextToken = firstToken
    return if (firstToken?.type in listOf(
            TokenType.OpenParenthesis,
            TokenType.DecimalLiteral,
            TokenType.Apostrophes
        ) || firstToken?.type == TokenType.Keyword && firstToken.content in listOf(
            Keyword.False.asString,
            Keyword.True.asString,
            Keyword.If.asString
        )
    ) {
        val children = mutableListOf<ParseTreeNode>()
        parseExpression(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.Val.asString)) {
        val children = mutableListOf<ParseTreeNode>()
        parseDeclaration(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseBlock(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "Block"
    var nextToken = firstToken
    return if (firstToken?.type in listOf(TokenType.OpenBraces)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, TokenType.OpenBraces)?.let {
            children.add(it.node); nextToken = it.nextToken
        }
        parseStatements(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        parseToken(nextToken, restOfTokens, TokenType.CloseBraces)?.let {
            children.add(it.node); nextToken = it.nextToken
        }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseDeclaration(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "Declaration"
    var nextToken = firstToken
    return if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.Val.asString)) {
        val children = mutableListOf<ParseTreeNode>()
        parseValDeclaration(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseValDeclaration(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "ValDeclaration"
    var nextToken = firstToken
    return if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.Val.asString)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, Keyword.Val)?.let { children.add(it.node); nextToken = it.nextToken }
        parseSpacePlus(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        parseToken(nextToken, restOfTokens, TokenType.SimpleName)?.let {
            children.add(it.node); nextToken = it.nextToken
        }
        parseSpaceStar(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        parseToken(nextToken, restOfTokens, TokenType.Colon)?.let { children.add(it.node); nextToken = it.nextToken }
        parseSpaceStar(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        parseToken(nextToken, restOfTokens, TokenType.SimpleName)?.let {
            children.add(it.node); nextToken = it.nextToken
        }
        parseSpaceStar(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        parseToken(nextToken, restOfTokens, TokenType.Assignment)?.let {
            children.add(it.node); nextToken = it.nextToken
        }
        parsePaddedExpression(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parsePaddedExpression(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "PaddedExpression"
    var nextToken = firstToken
    return if (true || firstToken?.type in listOf(TokenType.Whitespace)) {
        val children = mutableListOf<ParseTreeNode>()
        parseSpaceStar(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        parseExpression(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        parseSpaceStar(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseExpression(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "Expression"
    var nextToken = firstToken
    return if (firstToken?.type in listOf(TokenType.DecimalLiteral)) {
        val children = mutableListOf<ParseTreeNode>()
        parseNumber(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(
            Keyword.False.asString,
            Keyword.True.asString
        )
    ) {
        val children = mutableListOf<ParseTreeNode>()
        parseBooleanLiteral(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.Apostrophes)) {
        val children = mutableListOf<ParseTreeNode>()
        parseStringLiteral(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.If.asString)) {
        val children = mutableListOf<ParseTreeNode>()
        parseIfExpression(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.OpenParenthesis)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, TokenType.OpenParenthesis)?.let {
            children.add(it.node); nextToken = it.nextToken
        }
        parsePaddedExpression(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        parseToken(nextToken, restOfTokens, TokenType.CloseParenthesis)?.let {
            children.add(it.node); nextToken = it.nextToken
        }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseBooleanLiteral(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "BooleanLiteral"
    var nextToken = firstToken
    return if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.False.asString)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, Keyword.False)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.True.asString)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, Keyword.True)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseNumber(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "Number"
    var nextToken = firstToken
    return if (firstToken?.type in listOf(TokenType.DecimalLiteral)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, TokenType.DecimalLiteral)?.let {
            children.add(it.node); nextToken = it.nextToken
        }
        parseNumberRest(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseNumberRest(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "NumberRest"
    var nextToken = firstToken
    return if (firstToken?.type in listOf(TokenType.Dot)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, TokenType.Dot)?.let { children.add(it.node); nextToken = it.nextToken }
        parseToken(nextToken, restOfTokens, TokenType.DecimalLiteral)?.let {
            children.add(it.node); nextToken = it.nextToken
        }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else ParseTreeNodeResult(ParseTreeNode.EpsilonLeaf(nodeName), nextToken)
}

fun parseStringLiteral(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "StringLiteral"
    var nextToken = firstToken
    return if (firstToken?.type in listOf(TokenType.Apostrophes)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, TokenType.Apostrophes)?.let {
            children.add(it.node); nextToken = it.nextToken
        }
        parseAnythingEndsWithApostrophes(nextToken, restOfTokens)?.let {
            children.add(it.node); nextToken = it.nextToken
        }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseAnythingButApostrophes(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "AnythingButApostrophes"
    var nextToken = firstToken
    return if (firstToken?.type in listOf(TokenType.SEMI)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, TokenType.SEMI)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.Whitespace)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, TokenType.Whitespace)?.let {
            children.add(it.node); nextToken = it.nextToken
        }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.Dot)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, TokenType.Dot)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.Colon)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, TokenType.Colon)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.Assignment)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, TokenType.Assignment)?.let {
            children.add(it.node); nextToken = it.nextToken
        }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.OpenParenthesis)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, TokenType.OpenParenthesis)?.let {
            children.add(it.node); nextToken = it.nextToken
        }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.CloseParenthesis)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, TokenType.CloseParenthesis)?.let {
            children.add(it.node); nextToken = it.nextToken
        }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.OpenBraces)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, TokenType.OpenBraces)?.let {
            children.add(it.node); nextToken = it.nextToken
        }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.CloseBraces)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, TokenType.CloseBraces)?.let {
            children.add(it.node); nextToken = it.nextToken
        }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.DecimalLiteral)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, TokenType.DecimalLiteral)?.let {
            children.add(it.node); nextToken = it.nextToken
        }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.False.asString)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, Keyword.False)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.True.asString)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, Keyword.True)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.Val.asString)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, Keyword.Val)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.If.asString)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, Keyword.If)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.Else.asString)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, Keyword.Else)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.SimpleName)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, TokenType.SimpleName)?.let {
            children.add(it.node); nextToken = it.nextToken
        }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.Unknown)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, TokenType.Unknown)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseAnythingEndsWithApostrophes(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "AnythingEndsWithApostrophes"
    var nextToken = firstToken
    return if (firstToken?.type in listOf(
            TokenType.SEMI,
            TokenType.Whitespace,
            TokenType.Dot,
            TokenType.Colon,
            TokenType.Assignment,
            TokenType.OpenParenthesis,
            TokenType.CloseParenthesis,
            TokenType.OpenBraces,
            TokenType.CloseBraces,
            TokenType.DecimalLiteral,
            TokenType.SimpleName,
            TokenType.Unknown
        ) || firstToken?.type == TokenType.Keyword && firstToken.content in listOf(
            Keyword.False.asString,
            Keyword.True.asString,
            Keyword.Val.asString,
            Keyword.If.asString,
            Keyword.Else.asString
        )
    ) {
        val children = mutableListOf<ParseTreeNode>()
        parseAnythingButApostrophes(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        parseAnythingEndsWithApostrophes(nextToken, restOfTokens)?.let {
            children.add(it.node); nextToken = it.nextToken
        }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.Apostrophes)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, TokenType.Apostrophes)?.let {
            children.add(it.node); nextToken = it.nextToken
        }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseIfExpression(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "IfExpression"
    var nextToken = firstToken
    return if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.If.asString)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, Keyword.If)?.let { children.add(it.node); nextToken = it.nextToken }
        parseSpaceStar(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        parseToken(nextToken, restOfTokens, TokenType.OpenParenthesis)?.let {
            children.add(it.node); nextToken = it.nextToken
        }
        parsePaddedExpression(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        parseToken(nextToken, restOfTokens, TokenType.CloseParenthesis)?.let {
            children.add(it.node); nextToken = it.nextToken
        }
        parseSpaceStar(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        parseBlock(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        parseSpaceStar(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        parseToken(nextToken, restOfTokens, Keyword.Else)?.let { children.add(it.node); nextToken = it.nextToken }
        parseSpaceStar(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        parseBlock(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseSpacePlus(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "SpacePlus"
    var nextToken = firstToken
    return if (firstToken?.type in listOf(TokenType.Whitespace)) {
        val children = mutableListOf<ParseTreeNode>()
        parseToken(nextToken, restOfTokens, TokenType.Whitespace)?.let {
            children.add(it.node); nextToken = it.nextToken
        }
        parseSpacePlusRest(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseSpacePlusRest(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "SpacePlusRest"
    var nextToken = firstToken
    return if (firstToken?.type in listOf(TokenType.Whitespace)) {
        val children = mutableListOf<ParseTreeNode>()
        parseSpacePlus(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else ParseTreeNodeResult(ParseTreeNode.EpsilonLeaf(nodeName), nextToken)
}

fun parseSpaceStar(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "SpaceStar"
    var nextToken = firstToken
    return if (firstToken?.type in listOf(TokenType.Whitespace)) {
        val children = mutableListOf<ParseTreeNode>()
        parseSpacePlus(nextToken, restOfTokens)?.let { children.add(it.node); nextToken = it.nextToken }
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else ParseTreeNodeResult(ParseTreeNode.EpsilonLeaf(nodeName), nextToken)
}