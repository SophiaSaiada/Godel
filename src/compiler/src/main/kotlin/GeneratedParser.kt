package com.godel.compiler

data class ParseTreeNodeResult(
    val node: ParseTreeNode,
    val nextToken: Token?
)

data class ComposedParseTreeNodeResult(
    val children: List<ParseTreeNode>,
    val nextToken: Token?
)

const val ANSI_LEAF = "\u001B[42m\u001B[30m"
const val ANSI_RESET = "\u001B[0m"


private fun ParseTreeNode.asTreeString() =
    this.asTreeString("", true).joinToString("\n")

private fun ParseTreeNode.asTreeString(prefix: String, isTail: Boolean): List<String> =
    when (this) {
        is ParseTreeNode.Inner -> {
            val header = (prefix + (if (isTail) "└── " else "├── ") + name)
            listOf(header) +
                    children.dropLast(1).flatMap {
                        it.asTreeString(prefix + if (isTail) "    " else "│   ", false)
                    } +
                    (children.lastOrNull()?.asTreeString(
                        prefix + if (isTail) "    " else "│   ",
                        true
                    ) ?: emptyList())

        }
        is ParseTreeNode.Leaf ->
            listOf(prefix + (if (isTail) "└── " else "├── ") + ANSI_LEAF + token.content + ANSI_RESET)
        is ParseTreeNode.EpsilonLeaf ->
            listOf(prefix + (if (isTail) "└── " else "├── ") + "$name -> ε")
    }


fun parseToken(tokenType: TokenType) =
    { firstToken: Token?, restOfTokens: Iterator<Token> ->
        if (firstToken?.type == tokenType)
            ParseTreeNodeResult(ParseTreeNode.Leaf(firstToken), restOfTokens.nextOrNull())
        else throw java.lang.RuntimeException("parseToken: $firstToken, $tokenType")
    }

fun parseToken(keyword: Keyword) =
    { firstToken: Token?, restOfTokens: Iterator<Token> ->
        if (firstToken?.equals(keyword) == true)
            ParseTreeNodeResult(ParseTreeNode.Leaf(firstToken), restOfTokens.nextOrNull())
        else throw java.lang.RuntimeException("parseToken: $firstToken, $keyword")
    }

fun composeParseCalls(vararg parseFunctions: (Token?, Iterator<Token>) -> ParseTreeNodeResult?): (Token?, Iterator<Token>) -> ComposedParseTreeNodeResult =
    { firstToken: Token?, tokensSequence: Iterator<Token> ->
        val (children, nextToken) =
            parseFunctions.fold(
                ComposedParseTreeNodeResult(emptyList(), firstToken)
            ) { (children: List<ParseTreeNode>, nextToken: Token?), parseFunction: (Token?, Iterator<Token>) -> ParseTreeNodeResult? ->
                val parseResult = parseFunction(nextToken, tokensSequence)
                if (parseResult?.node == null)
                    throw RuntimeException("Parse Error while parsing $nextToken with ${parseFunction.javaClass.simpleName}.")
                ComposedParseTreeNodeResult(children + listOf(parseResult.node), parseResult.nextToken)
            }
        ComposedParseTreeNodeResult(children, nextToken)
    }


fun main() {
    val s1 =
        Lexer.lex(
            "if (true) { val x:   Int = 3.2 } else { val y: String = \"hello 12 world!\"; 3.2 } "
                .asSequence()
        ).iterator()
    print(parseStatements(s1.nextOrNull(), s1)?.node?.asTreeString())
}


// This part is auto-generated by the ParserGenerator
fun parseStatements(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "Statements"
    return if (firstToken?.type in listOf(TokenType.WhiteSpace, TokenType.BreakLine, TokenType.OpenParenthesis, TokenType.DecimalLiteral, TokenType.Apostrophes) || firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.False.asString, Keyword.True.asString, Keyword.If.asString, Keyword.Val.asString)) {
        val (children, nextToken) =
            composeParseCalls(::parsePaddedStatement, ::parseStatementsRest).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseStatementsRest(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "StatementsRest"
    return if (firstToken?.type in listOf(TokenType.SemiColon, TokenType.BreakLine)) {
        val (children, nextToken) =
            composeParseCalls(::parseSEMI, ::parseStatements).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else ParseTreeNodeResult(ParseTreeNode.EpsilonLeaf(nodeName), firstToken)
}

fun parsePaddedStatement(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "PaddedStatement"
    return if (firstToken?.type in listOf(TokenType.WhiteSpace, TokenType.BreakLine)) {
        val (children, nextToken) =
            composeParseCalls(::parseSpacePlus, ::parseStatement, ::parseSpaceStar).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.OpenParenthesis, TokenType.DecimalLiteral, TokenType.Apostrophes) || firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.False.asString, Keyword.True.asString, Keyword.If.asString, Keyword.Val.asString)) {
        val (children, nextToken) =
            composeParseCalls(::parseStatement, ::parseSpaceStar).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseStatement(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "Statement"
    return if (firstToken?.type in listOf(TokenType.OpenParenthesis, TokenType.DecimalLiteral, TokenType.Apostrophes) || firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.False.asString, Keyword.True.asString, Keyword.If.asString)) {
        val (children, nextToken) =
            composeParseCalls(::parseExpression).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.Val.asString)) {
        val (children, nextToken) =
            composeParseCalls(::parseDeclaration).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseBlock(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "Block"
    return if (firstToken?.type in listOf(TokenType.OpenBraces)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(TokenType.OpenBraces), ::parseStatements, parseToken(TokenType.CloseBraces)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseDeclaration(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "Declaration"
    return if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.Val.asString)) {
        val (children, nextToken) =
            composeParseCalls(::parseValDeclaration).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseValDeclaration(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "ValDeclaration"
    return if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.Val.asString)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(Keyword.Val), ::parseSpacePlus, parseToken(TokenType.SimpleName), ::parseSpaceStar, parseToken(TokenType.Colon), ::parseSpaceStar, parseToken(TokenType.SimpleName), ::parseSpaceStar, parseToken(TokenType.Assignment), ::parsePaddedExpression).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parsePaddedExpression(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "PaddedExpression"
    return if (true || firstToken?.type in listOf(TokenType.WhiteSpace, TokenType.BreakLine)) {
        val (children, nextToken) =
            composeParseCalls(::parseSpaceStar, ::parseExpression, ::parseSpaceStar).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseExpression(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "Expression"
    return if (firstToken?.type in listOf(TokenType.DecimalLiteral)) {
        val (children, nextToken) =
            composeParseCalls(::parseNumber).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.False.asString, Keyword.True.asString)) {
        val (children, nextToken) =
            composeParseCalls(::parseBooleanLiteral).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.Apostrophes)) {
        val (children, nextToken) =
            composeParseCalls(::parseStringLiteral).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.If.asString)) {
        val (children, nextToken) =
            composeParseCalls(::parseIfExpression).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.OpenParenthesis)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(TokenType.OpenParenthesis), ::parsePaddedExpression, parseToken(TokenType.CloseParenthesis)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseBooleanLiteral(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "BooleanLiteral"
    return if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.False.asString)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(Keyword.False)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.True.asString)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(Keyword.True)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseNumber(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "Number"
    return if (firstToken?.type in listOf(TokenType.DecimalLiteral)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(TokenType.DecimalLiteral), ::parseNumberRest).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseNumberRest(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "NumberRest"
    return if (firstToken?.type in listOf(TokenType.Dot)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(TokenType.Dot), parseToken(TokenType.DecimalLiteral)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else ParseTreeNodeResult(ParseTreeNode.EpsilonLeaf(nodeName), firstToken)
}

fun parseStringLiteral(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "StringLiteral"
    return if (firstToken?.type in listOf(TokenType.Apostrophes)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(TokenType.Apostrophes), ::parseAnythingEndsWithApostrophes).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseAnythingButApostrophes(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "AnythingButApostrophes"
    return if (firstToken?.type in listOf(TokenType.SemiColon)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(TokenType.SemiColon)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.BreakLine)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(TokenType.BreakLine)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.WhiteSpace)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(TokenType.WhiteSpace)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.Dot)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(TokenType.Dot)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.Colon)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(TokenType.Colon)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.Assignment)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(TokenType.Assignment)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.OpenParenthesis)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(TokenType.OpenParenthesis)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.CloseParenthesis)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(TokenType.CloseParenthesis)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.OpenBraces)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(TokenType.OpenBraces)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.CloseBraces)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(TokenType.CloseBraces)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.DecimalLiteral)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(TokenType.DecimalLiteral)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.False.asString)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(Keyword.False)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.True.asString)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(Keyword.True)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.Val.asString)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(Keyword.Val)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.If.asString)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(Keyword.If)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.Else.asString)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(Keyword.Else)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.SimpleName)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(TokenType.SimpleName)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.Unknown)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(TokenType.Unknown)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseAnythingEndsWithApostrophes(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "AnythingEndsWithApostrophes"
    return if (firstToken?.type in listOf(TokenType.SemiColon, TokenType.BreakLine, TokenType.WhiteSpace, TokenType.Dot, TokenType.Colon, TokenType.Assignment, TokenType.OpenParenthesis, TokenType.CloseParenthesis, TokenType.OpenBraces, TokenType.CloseBraces, TokenType.DecimalLiteral, TokenType.SimpleName, TokenType.Unknown) || firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.False.asString, Keyword.True.asString, Keyword.Val.asString, Keyword.If.asString, Keyword.Else.asString)) {
        val (children, nextToken) =
            composeParseCalls(::parseAnythingButApostrophes, ::parseAnythingEndsWithApostrophes).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.Apostrophes)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(TokenType.Apostrophes)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseIfExpression(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "IfExpression"
    return if (firstToken?.type == TokenType.Keyword && firstToken.content in listOf(Keyword.If.asString)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(Keyword.If), ::parseSpaceStar, parseToken(TokenType.OpenParenthesis), ::parsePaddedExpression, parseToken(TokenType.CloseParenthesis), ::parseSpaceStar, ::parseBlock, ::parseSpaceStar, parseToken(Keyword.Else), ::parseSpaceStar, ::parseBlock).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseSpacePlus(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "SpacePlus"
    return if (firstToken?.type in listOf(TokenType.WhiteSpace, TokenType.BreakLine)) {
        val (children, nextToken) =
            composeParseCalls(::parseWhiteSpaceOrBreakLine, ::parseSpacePlusRest).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseSpacePlusRest(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "SpacePlusRest"
    return if (firstToken?.type in listOf(TokenType.WhiteSpace, TokenType.BreakLine)) {
        val (children, nextToken) =
            composeParseCalls(::parseSpacePlus).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else ParseTreeNodeResult(ParseTreeNode.EpsilonLeaf(nodeName), firstToken)
}

fun parseSpaceStar(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "SpaceStar"
    return if (firstToken?.type in listOf(TokenType.WhiteSpace, TokenType.BreakLine)) {
        val (children, nextToken) =
            composeParseCalls(::parseSpacePlus).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else ParseTreeNodeResult(ParseTreeNode.EpsilonLeaf(nodeName), firstToken)
}

fun parseWhiteSpaceOrBreakLine(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "WhiteSpaceOrBreakLine"
    return if (firstToken?.type in listOf(TokenType.WhiteSpace)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(TokenType.WhiteSpace)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.BreakLine)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(TokenType.BreakLine)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}

fun parseSEMI(firstToken: Token?, restOfTokens: Iterator<Token>): ParseTreeNodeResult? {
    val nodeName = "SEMI"
    return if (firstToken?.type in listOf(TokenType.SemiColon)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(TokenType.SemiColon)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else if (firstToken?.type in listOf(TokenType.BreakLine)) {
        val (children, nextToken) =
            composeParseCalls(parseToken(TokenType.BreakLine)).invoke(firstToken, restOfTokens)
        ParseTreeNodeResult(ParseTreeNode.Inner(children, nodeName), nextToken)
    } else return null
}