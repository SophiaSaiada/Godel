package com.godel.compiler


object SequenceSplitter {
    /**
     * The returned sub-sequences are generated by scanning the original sequence,
     * and for each item yielding it as a part of the current sub-sequence,
     * or as a new sub-sequence with a single item (if it satisfies the predicate).
     *
     * @param sequence the sequence to split
     * @param predicate the predicate to split by it
     * @return Sequence of sub-sequence generated by splitting the original sequence around items that satisfy the predicate
     */
    fun <T : Any> splitAndKeepDelimiters(
        sequence: Sequence<T>,
        predicate: (T) -> Boolean
    ): Sequence<Sequence<T>> {
        val iterator = sequence.iterator()
        return kotlin.sequences.sequence {
            for (item in iterator) {
                if (predicate(item)) {
                    yield(sequenceOf(item))
                } else {
                    var capturedDelimiter: T? = null
                    yield(kotlin.sequences.sequence {
                        yield(item)
                        for (innerItem in iterator) {
                            if (predicate(innerItem)) {
                                capturedDelimiter = innerItem
                                break
                            } else yield(innerItem)
                        }
                    })
                    // We can iterate over the original sequence only once.
                    // So, if we captured an item that satisfy the predicate in the inner loop,
                    // we can't "go back" one step and retrieve it again from the iterator,
                    // we have to store in in some local variable.
                    capturedDelimiter?.let { yield(sequenceOf(it)) }
                }
            }
        }
    }

    /**
     * The returned sub-sequences are generated by scanning the original sequence,
     * and for each item yielding it as a part of the current sub-sequence.
     * If the current item satisfies the predicate, it would be yielded as a start of a new sub-sequence.
     *
     * @param sequence the sequence to split
     * @param predicate the predicate to split by it
     * @return Sequence of sub-sequence generated by splitting the original sequence before each item that satisfies the predicate
     */
    fun <T : Any> splitAndJoinDelimiters(
        sequence: Sequence<T>,
        predicate: (T) -> Boolean
    ): Sequence<Sequence<T>> {
        val iterator = sequence.iterator()

        return kotlin.sequences.sequence {
            var isFirstItem = true
            var capturedDelimiter: T? = null
            while (iterator.hasNext()) {
                yield(kotlin.sequences.sequence {
                    capturedDelimiter?.let { yield(it) }
                    capturedDelimiter = null

                    for (innerItem in iterator) {
                        if (isFirstItem && predicate(innerItem)) {
                            // We don't want to yield an empty sequence.
                            // It can be happen only in one situation: the first item satisfies the predicate.
                            yield(innerItem)
                            isFirstItem = false
                        } else if (predicate(innerItem)) {
                            capturedDelimiter = innerItem
                            break
                        } else yield(innerItem)
                    }
                })
            }
            // The case which the last item satisfies the predicate, won't be handled in the loop,
            // because in the next iteration, the iterator won't have next items.
            capturedDelimiter?.let { yield(sequenceOf(it)) }
        }
    }

}